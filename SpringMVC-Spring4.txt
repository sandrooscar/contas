*** AULA01
O Spring MVC é um framework Java que ajuda no desenvolvimento de aplicações Web. 
Ele, como a grande maioria dos frameworks modernos, usa o padrão MVC.

Spring é uma servlet e precisa estar declarado no web.xml

	<!-- Declaracao do servlet do Spring MVC abaixo-->
	<servlet>
		<servlet-name>spring mvc</servlet-name>
		<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
		<init-param>
			<param-name>contextConfigLocation</param-name>
			<param-value>/WEB-INF/spring-context.xml</param-value>
		</init-param>
	</servlet>

Podemos verifica a inclusão de um arquivo de configuracao

		<init-param>
			<param-name>contextConfigLocation</param-name>
			<param-value>/WEB-INF/spring-context.xml</param-value>
		</init-param>

No Spring-context.xml é configurado o package base do springMVC que contem os modelos, controllers e daos
<context:component-scan base-package="br.com.caelum.contas" />

Indicado que as configurações serão feitas atraves de anotações
<mvc:annotation-driven />

No bean de viwer resolver é informado o prefixo onde são encontradas as urls e o sufixo da página web

	<bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
		<property name="prefix" value="/WEB-INF/views/" />
		<property name="suffix" value=".jsp" />
	</bean>
	
Nosso banco está criado. Você, mais para frente, pode trocar esse banco por um MySQL. Tudo que vai ter que 
fazer é mudar a string de conexão que está na classe ConnectionFactory, que se encontra no pacote br.com.caelum.contas!

Mapeando uma url

Na classe controller criar um método e adicionar o requestMapping, o retorna string é p nome da pagina que o spring exibirá 
ao acessar a URL (método). No exemplo abaixo ao acessar o browser em http://localhost:8080/contas/olaMundo ocorrerá redirecionamento para olaMundo.jsp
e o método será executado.
	
   @RequestMapping("/olaMundo")
	public String olaMundo() {
		System.out.println("Olá springMVC spring4");
		return "olaMundo";
	}
	
*** AULA03 - O PADRÂO MVC
Controller => recebe a requisição do usuário de checa quais regras deve executar
Model => possui as regras de negócio, que podem acessar inclusive o banco de dados, apos executar o  fluxo volta para o controller
View => parte que é retornada para o usuário

- MODELO: Todo sistema possui regras de negócios, que podem ser simples ou complexas. Todas elas devem estar separadas em classes que tem essa regras como única responsabilidade. Ou seja, toda e qualquer ação de regra de negócio deve ser realizada por exclusivamente esse conjunto de classes.

- VIEW: Interfaces de usuário também devem ser isoladas. Códigos de interface tendem a ser grandes e a sofrerem mudanças constantes. Por esse motivo, toda parte responsável pela exibição das informações para o usuário devem estar isoladas em outro ponto do sistema.

- CONTROLLER: Para conectar as ações que o usuário realiza na interface e fazer com que essas ações resultem em execuções de regra de negócio, é necessário que uma outra camada faça essa tarefa. Ou seja, essa camada recebe informações da camada de visualização e as transforma em invocações de regras de negócio.

O SpringMVC trabalha na camada de Controller, ele é quem controla as entradas e dispara as requisições internas para os controllers (classes com @Controller) e suas views.

* Quando uma requisição chega ao servidor, qual a ordem de execução comum?

Quando uma requisição chega, ela é prontamente atendida pelo Spring MVC. O framework então decide qual action chamar. A action executa, e ao final, diz ao framework qual JSP exibir. O Spring MVC por fim, pega a JSP, a processa, e envia para o usuário final, finalizando a requisição.

* É o modelo (ou domínio) que encapsula as regras de negócios do sistema. Classes como Conta, Usuario, e etc são classes do modelo, por exemplo. É lá que as regras de negócio devem existir.

Lembre-se de nunca colocar regras de negócio nos Controllers! Seu código vai ficar muito complicado!