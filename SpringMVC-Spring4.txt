*** AULA01
O Spring MVC é um framework Java que ajuda no desenvolvimento de aplicações Web. 
Ele, como a grande maioria dos frameworks modernos, usa o padrão MVC.

Spring é uma servlet e precisa estar declarado no web.xml

	<!-- Declaracao do servlet do Spring MVC abaixo-->
	<servlet>
		<servlet-name>spring mvc</servlet-name>
		<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
		<init-param>
			<param-name>contextConfigLocation</param-name>
			<param-value>/WEB-INF/spring-context.xml</param-value>
		</init-param>
	</servlet>

Podemos verifica a inclusão de um arquivo de configuracao

		<init-param>
			<param-name>contextConfigLocation</param-name>
			<param-value>/WEB-INF/spring-context.xml</param-value>
		</init-param>

No Spring-context.xml é configurado o package base do springMVC que contem os modelos, controllers e daos
<context:component-scan base-package="br.com.caelum.contas" />

Indicado que as configurações serão feitas atraves de anotações
<mvc:annotation-driven />

No bean de viwer resolver é informado o prefixo onde são encontradas as urls e o sufixo da página web

	<bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
		<property name="prefix" value="/WEB-INF/views/" />
		<property name="suffix" value=".jsp" />
	</bean>
	
Nosso banco está criado. Você, mais para frente, pode trocar esse banco por um MySQL. Tudo que vai ter que 
fazer é mudar a string de conexão que está na classe ConnectionFactory, que se encontra no pacote br.com.caelum.contas!

Mapeando uma url

Na classe controller criar um método e adicionar o requestMapping, o retorna string é p nome da pagina que o spring exibirá 
ao acessar a URL (método). No exemplo abaixo ao acessar o browser em http://localhost:8080/contas/olaMundo ocorrerá redirecionamento para olaMundo.jsp
e o método será executado.
	
   @RequestMapping("/olaMundo")
	public String olaMundo() {
		System.out.println("Olá springMVC spring4");
		return "olaMundo";
	}
	
*** AULA02 - O PADRÃO MVC
Controller => recebe a requisição do usuário de checa quais regras deve executar
Model => possui as regras de negócio, que podem acessar inclusive o banco de dados, apos executar o  fluxo volta para o controller
View => parte que é retornada para o usuário

- MODELO: Todo sistema possui regras de negócios, que podem ser simples ou complexas. Todas elas devem estar separadas em classes que tem essa regras como única responsabilidade. Ou seja, toda e qualquer ação de regra de negócio deve ser realizada por exclusivamente esse conjunto de classes.

- VIEW: Interfaces de usuário também devem ser isoladas. Códigos de interface tendem a ser grandes e a sofrerem mudanças constantes. Por esse motivo, toda parte responsável pela exibição das informações para o usuário devem estar isoladas em outro ponto do sistema.

- CONTROLLER: Para conectar as ações que o usuário realiza na interface e fazer com que essas ações resultem em execuções de regra de negócio, é necessário que uma outra camada faça essa tarefa. Ou seja, essa camada recebe informações da camada de visualização e as transforma em invocações de regras de negócio.

O SpringMVC trabalha na camada de Controller, ele é quem controla as entradas e dispara as requisições internas para os controllers (classes com @Controller) e suas views.

* Quando uma requisição chega ao servidor, qual a ordem de execução comum?

Quando uma requisição chega, ela é prontamente atendida pelo Spring MVC. O framework então decide qual action chamar. A action executa, e ao final, diz ao framework qual JSP exibir. O Spring MVC por fim, pega a JSP, a processa, e envia para o usuário final, finalizando a requisição.

* É o modelo (ou domínio) que encapsula as regras de negócios do sistema. Classes como Conta, Usuario, e etc são classes do modelo, por exemplo. É lá que as regras de negócio devem existir.

Lembre-se de nunca colocar regras de negócio nos Controllers! Seu código vai ficar muito complicado!

*** AULA03 - Recebendo dados da requisição
Um padrão que temos é de criar sub-diretórios para cada controlador. Então, todas as JSPs que são chamadas pelo ContaController, devem ficar dentro de views/conta.
A convenção também na maioria dos frameworks modernos. Isso ajuda e muito. No passado, nós éramos obrigados a popular na mão. Ou seja, para cada atributo da classe, gastávamos 1 ou mais linhas de código para guardar o valor que veio na requisição em um objeto de domínio. 
Imagine o trabalho quando o dado era um número ou uma data; precisávamos ficar convertendo!

Toda essa tarefa repetitiva agora é responsabilidade do Spring!

*** AULA04 - Enviando dados para a JSP
Utilização de Model e ModelAndView
No ModelAndView adiciono a JSP de retorno e o atributo com valor que será acessada por essa JSP.
O ModelAndView é utilizado quando precisamos enviar valores para a JSP.
A JSP acessa a lista de contas através do nome todasContas.
 
Link documentação JSTL
https://docs.oracle.com/javaee/5/tutorial/doc/bnakc.html

*** AULA05 - Redirecionando requisições
Com o FORWARD o próprio servidor faz o redirecionamento, o redirecionamento acontece no lado do servidor, o browser não percebe, 
mas a url fica com o link anterior ao forward, entao se der refresh apresentando a listagem de contas com de removeContas, o remove contas será chamado novamente, ou seja,
apresenta a listagem de contas após a remoção mas no entanto, no browser, a barra de endereços continua com o link de removerContas.


Com redirect o servidor solicita para o navegador fazer uma nova requisição para o endereço informado.
Requisição vaia para o servidor, o servidor solicita redirecionamento para a pagina de retorno (gera 302)
O navegador retonar para a pagina de redirecionamento informada pelo servidor

* Informando o springMVC como mconverter data
Para o Spring MVC saber converter automaticamente a data no formato brasileiro para um Calendar é preciso usar a anotação @DateTimeFormat. Abra a classe Conta e adicione a anotação acima do atributo dataPagamento:

@DateTimeFormat(pattern="dd/MM/yyyy")
private Calendar dataPagamento

Flash escope
https://vard-lokkur.blogspot.com/2012/02/spring-mvc-flash-attributes.html

Flash scope serve para quando fazemos um redirecionamento qualquer, e queremos que uma variável seja "transportada" de uma action para outra.

O escopo de flash é menor do que o escopo de Sessão (que discutiremos mais pra frente). Uma variável na flash vive somente durante 1 ou mais requisições que acontecem em sequência, devido a redirecionamentos.

*** AULA06 - Validação de dados
A partir do java 6 a sun criou o bean validation, funciona com anotações

Exibir erros no formulario, necessário adicionar a tag
<%@ taglib uri="http://www.springframework.org/tags/form" prefix="form" %>

Para fazer  internazionalização é necessário criar o arquivo ValidationMessages.properties na pastar src, o nome deve ser esse, 
pois está na especificação

https://blog.caelum.com.br/java-ee-6-comecando-com-bean-validation/

A validação no cliente é interessante, pois é bastante amigável ao usuário.

Porém a validação no servidor é importantíssima. É ela que vai garantir que nenhum dado sujo seja salvo no banco de dados. 
Sabemos que o usuário pode facilmente desativar o Javascript do browser, ou mesmo fazer uma requisição para o seu servidor 
na mão. Ou seja, validação server-side é obrigatória!

Devo sempre usar Bean Validation? Não posso fazer nada na mão?

O que você acha?

RESPONDA
Opinião do instrutor

Não há resposta certa para essa pergunta. Se você perceber que a validação manual será mais simples, faça também. Não há problemas 
em misturar, contanto que isso fique claro e fácil de ser percebido por qualquer um que vá manter sua aplicação no futuro.



